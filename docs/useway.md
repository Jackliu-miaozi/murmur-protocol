# Murmur Protocol 使用场景描述

本文档描述了 Murmur Protocol 的完整使用场景，展示了从创建议题到最终 NFT 铸造的完整流程。

---

## 场景设定

Alice 想要发起一个关于"Web3 未来发展方向"的 24 小时实时讨论，并将精彩讨论内容铸造成 NFT 永久保存。

---

## 完整使用流程

### 第1步：创建议题

**时间：2024年1月1日 00:00**

Alice 准备创建议题，需要完成以下步骤：

1. **铸造 vDOT**：使用 1000 DOT 铸造 1000 vDOT

2. **质押 vDOT 获得 VP**：
   - 调用 VPToken 合约质押 vDOT 获得 VP（发言点数）
   - 系统计算：`VP = 100 * √vDOT`（例如：1000 vDOT 获得约 3162 VP）
   - vDOT 锁定在 VPToken 合约中，VP 存储在 VPToken 合约中
   - **注意**：VP 是全局的，可以在不同 topic 中使用；而参与特定 topic 时，通过 TopicVault 锁定 vDOT 获得的是该 topic 专用的 VP

3. **查询创建费用**：
   - 调用 `TopicFactory.quoteCreationCost()` 查询当前创建 topic 所需的 VP 成本
   - 创建成本公式：`成本 = 基础成本 × (1 + α × log(1 + 活跃topic数量))`
     - 基础成本：1000 VP（默认值，可配置）
     - 增长系数：α = 2.0（默认值，可配置）
     - 活跃 topic 数量：当前状态为 Live 且未到期的 topic 数量
   - 示例：当有 10 个活跃 topic 时，成本约为 1182 VP

4. **创建议题**：
   - 调用 `TopicFactory.createTopic(metadataHash, topicDuration_, freezeWindow_, curatedLimit_)`
   - **系统自动从 VPToken 合约中扣除创建费用**：
     - 检查用户的 VP 余额是否足够支付创建费用
     - 如果余额不足，交易失败
     - 如果余额充足，从 VPToken 合约中销毁相应数量的 VP
   - 参数设置：
     - `metadataHash`: 议题元数据哈希（包含标题、描述等）
       - 元数据存储在链下（如 IPFS），包含标题、描述、创建者信息等
       - 链上仅存储元数据的哈希值，用于验证和引用
     - `topicDuration_`: `86400` 秒（24小时）
     - `freezeWindow_`: `600` 秒（10分钟冻结窗口）
     - `curatedLimit_`: `50`（最多50条精选消息）
   - 系统创建 `topicId = 1`，状态为 `Live`，开始计时
   - **创建者权限**：创建者可以修改议题参数（如冻结窗口、精选上限等），但不需要持续参与，也没有额外的 VP 奖励或成本

---

### 第2步：用户参与讨论

**时间：2024年1月1日 00:30**

Bob 想要参与讨论，需要完成以下步骤：

1. **锁定 vDOT 获得 VP**：
   - 调用 `TopicVault.lockVdot(topicId=1, amount=1000)`
   - 系统计算：`VP = 100 * √1000 ≈ 3162 VP`
   - 铸造 3162 个 VP Token 给 Bob（该 topic 专用）
   - **注意**：这里的锁定仅涉及 VP 的生成，不直接锁定 vDOT。vDOT 的赎回需要等待用户参与的所有 topic 都结束后才能进行

2. **发布消息**：
   - Bob 准备消息："我认为 Web3 的核心是去中心化身份..."
   - **消息内容存储**：消息完整内容存储在链下（如 IPFS），链上仅存储 `contentHash`
   - **AI 服务调用**：
     - 前端调用 AI 服务，AI 返回表达强度分数 `S ∈ [0,1]`
     - AI 服务对消息内容、强度分数、时间戳等信息生成签名
     - 签名格式遵循 EIP-712 标准，包含消息哈希、强度分数、时间戳等字段
     - 如果 AI 服务不可用，系统支持降级策略（如使用默认强度分数或允许用户手动确认）
   - 调用 `MessageRegistry.postMessage(topicId, contentHash, length, aiScore, signature)`：
     - 验证 AI 签名（通过 AIScoreVerifier 合约）
     - **计算发言成本**：
       - 完整公式：`Cost = Base(H) × Intensity(S) × Length(L)`
       - `Base(H) = c0 × (1 + β × H)`
         - `c0 = 10`（基础成本，VP）
         - `β = 0.25`（热度系数）
         - `H` 为议题热度（见下方热度计算）
       - `Intensity(S) = 1 + α × S^p`
         - `α = 2.0`（强度系数）
         - `p = 2.0`（强度指数）
         - `S` 为 AI 返回的表达强度分数
       - `Length(L) = 1 + γ × log(1 + L)`
         - `γ = 0.15`（长度系数）
         - `L` 为消息字符长度
     - **热度计算**（影响 Base(H)）：
       - `H = w1×log(1+msg_rate) + w2×log(1+unique_users) + w3×log(1+like_rate) + w4×log(1+vp_burn_rate)`
       - 热度由消息速率、独立参与地址数、点赞速率、VP 消耗速率综合计算
       - 热度越高，基础发言成本越高（热度税机制）
       - 热度实时更新，每次发消息时重新计算
     - **限速机制**：
       - 最小发消息间隔：15 秒
       - 连续发送冷却：每 3 条消息后，第 4 条消息成本增加 1.1 倍
       - 如果违反限速规则，交易会失败
     - 销毁相应数量的 VP
     - 消息 contentHash 存储在链上，获得 `messageId = 1`
     - **错误处理**：
       - 如果 VP 余额不足，交易失败，用户需要先获得更多 VP
       - 如果 AI 签名验证失败，交易失败，需要重新获取 AI 签名
       - 如果违反限速规则，交易失败，需要等待冷却时间

---

### 第3步：点赞与精选

**时间：2024年1月1日 02:00 - 23:50**

1. **其他用户点赞**：
   - Charlie 点赞 Bob 的消息：`MessageRegistry.likeMessage(topicId=1, messageId=1)`
   - **点赞成本**：每次点赞需要消耗 1 VP
   - 每次点赞都会触发 `CurationModule.onLike()`，系统重新计算精选区

2. **精选区动态排序机制**：
   - 精选区始终保持点赞数排名最靠前的前 50 条消息（数量由创建 topic 时设定的 `curatedLimit_` 参数决定）
   - **排序规则**：
     - 主要排序：按点赞数从高到低
     - 次要排序：如果点赞数相同，按消息发布时间从新到旧（时间倒序）
   - 系统检查是否在冻结窗口（否，可以更新）
   - 当消息的点赞数变化时，系统会：
     - 如果精选区未满（当前 0/50），直接加入点赞数最高的消息
     - 如果精选区已满，比较新消息的点赞数与精选区中点赞数最低的消息
     - 如果新消息点赞数更高，则替换掉点赞数最低的消息
   - Bob 的消息（点赞数 10）进入精选区，`curatedMessages[1] = [1]`
   - **精选区数量不足的情况**：如果议题结束时精选区消息数量不足 50 条，系统会挑选 VP 消耗最多的前 50 条消息（按 VP 消耗量排序）

3. **精选区持续更新**：
   - 随着讨论进行，更多消息获得点赞
   - 精选区动态调整，始终保持点赞数排名前 50 的消息
   - 如果某条消息的点赞数被其他消息超越，会被移出精选区

---

### 第4步：冻结窗口

**时间：2024年1月1日 23:50 - 24:00**

- 议题进入最后 10 分钟冻结窗口
- **冻结窗口检测机制**：合约无法自动执行，必须通过用户操作触发。当用户进行任何操作时（点赞、发消息等），合约会通过 `block.timestamp` 检查当前时间，判断是否已进入冻结窗口
- 当 `TopicFactory.isFrozen(topicId=1)` 返回 `true` 时：
  - **精选区锁定**：精选区不再更新，即使有新消息获得更多点赞也不会替换现有精选消息
  - 用户仍可继续讨论和点赞，但点赞数变化不会影响精选区排序

---

### 第5步：议题结束

**时间：2024年1月2日 00:00**

1. **关闭议题**：
   - **自动关闭机制**：
     - 任何人向 topic 发送消息都触发 topic 的自我检查
     - 如果当前时间已超过 `topicDuration_`，自动将状态变为 `Closed`
   - **定时关闭机制**：
     - 支持定时关闭，由网站后台自动触发
     - 当议题到达结束时间时，后台服务调用合约关闭议题
   - 议题关闭后，状态变为 `Closed`

2. **计算精选集合哈希**：
   - 调用 `CurationModule.curatedSetHash(topicId=1)`
   - 返回精选消息列表的哈希值

---

### 第6步：铸造 NFT 记忆

**时间：2024年1月2日 00:10**

**授权铸造者**：任何在该议题中发过言的用户都可以成为授权铸造者，调用 `NFTMinter.mintNfts(topicId)`：

1. 检查议题是否可赎回（状态为 `Closed`）
2. 检查是否已铸造（否）
3. 铸造 NFT，包含：
   - 议题元数据哈希
   - 精选集合哈希（精选消息的哈希，如果不足 50 条则按 VP 消耗量选择前 50 条）
   - 版本号（Version）
4. 调用 `TopicFactory.markMinted()` 标记已铸造
5. **VP 返还机制**：
   - 返还给所有参与该议题的用户（包括发消息和点赞的用户）
   - 返还方式：恢复用户在 VPToken 合约中的 VP 余额
   - 返还的 VP 可以继续使用（可用于其他 topic 或创建新 topic）
   - 返还数量 = 用户在该议题中所有已消耗的 VP 点数
6. Topic 状态变为 `Minted`

---

### 第7步：用户赎回 vDOT

**时间：2024年1月2日 00:20**

Bob 想赎回之前锁定的 vDOT：

- 调用 `TopicVault.redeemVdot()`
- **系统检查赎回条件**：该用户所参与的所有 topic 必须已经结束
- **Topic 状态说明**：
  - `Closed`：议题已到期关闭，但尚未铸造 NFT
  - `Minted`：议题已关闭且已铸造 NFT，VP 已返还给用户
  - `Settled`：所有流程完成，用户已赎回 vDOT
- **赎回规则**：
  - 如果用户参与了多个 topic，需要等待所有参与的 topic 均已经结束后才能一次性赎回所有 vDOT
  - 不支持按 topic 分别赎回，必须全部结束后统一赎回
  - 每个 topic 的锁定仅涉及 VP 的生成和消耗，不直接锁定 vDOT
  - vDOT 的赎回是基于用户在 VPToken 合约中的整体质押状态
- 赎回条件满足后，可以返回相应数量的 vDOT 给 Bob
- **注意**：VP Token 在议题结束后作废，但通过 NFT 铸造返还的 VP 可以继续使用

---
